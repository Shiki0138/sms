const request = require('supertest');
const app = require('../../../backend/src/server');

describe('OWASP Top 10 セキュリティテスト', () => {
  
  describe('A01: Broken Access Control (認可制御の不備)', () => {
    
    test('未認証ユーザーは保護されたエンドポイントにアクセスできない', async () => {
      const protectedEndpoints = [
        '/api/v1/analytics/dashboard-kpis',
        '/api/v1/customers',
        '/api/v1/reservations',
        '/api/v1/messages',
        '/api/v1/staff'
      ];

      for (const endpoint of protectedEndpoints) {
        const response = await request(app)
          .get(endpoint)
          .expect(401);
        
        expect(response.body).toMatchObject({
          error: expect.stringMatching(/unauthorized|authentication/i)
        });
      }
    });

    test('無効なJWTトークンでアクセスが拒否される', async () => {
      const invalidTokens = [
        'invalid-token',
        'Bearer invalid-token',
        'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.invalid',
        ''
      ];

      for (const token of invalidTokens) {
        const response = await request(app)
          .get('/api/v1/analytics/dashboard-kpis')
          .set('Authorization', token)
          .expect(401);
        
        expect(response.body.error).toBeDefined();
      }
    });

    test('期限切れトークンでアクセスが拒否される', async () => {
      // 期限切れトークンを生成（テスト用）
      const expiredToken = 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJleHAiOjE1MTYyMzkwMjJ9.invalid';
      
      const response = await request(app)
        .get('/api/v1/analytics/dashboard-kpis')
        .set('Authorization', expiredToken)
        .expect(401);
      
      expect(response.body.error).toMatch(/expired|invalid/i);
    });

    test('他テナントのデータにアクセスできない', async () => {
      // 正常なトークンで異なるテナントIDを指定
      const validToken = await getValidTestToken();
      
      const response = await request(app)
        .get('/api/v1/customers')
        .set('Authorization', `Bearer ${validToken}`)
        .set('x-tenant-id', 'unauthorized-tenant')
        .expect(403);
      
      expect(response.body.error).toMatch(/forbidden|access denied/i);
    });
  });

  describe('A02: Cryptographic Failures (暗号化の失敗)', () => {
    
    test('パスワードがハッシュ化されて保存される', async () => {
      const response = await request(app)
        .post('/api/v1/auth/register')
        .send({
          email: 'test-crypto@example.com',
          password: 'plaintext-password',
          name: 'Test User',
          tenantId: 'test-tenant'
        });

      // パスワードが平文で返されないことを確認
      expect(response.body.password).toBeUndefined();
      expect(response.body.user?.password).toBeUndefined();
    });

    test('機密データが暗号化されて送信される', async () => {
      // HTTPSでない場合は警告またはエラー
      const response = await request(app)
        .get('/health')
        .expect(200);
      
      // セキュリティヘッダーの確認
      expect(response.headers).toHaveProperty('strict-transport-security');
    });

    test('セッション管理が安全に行われる', async () => {
      const response = await request(app)
        .post('/api/v1/auth/login')
        .send({
          email: 'test@example.com',
          password: 'password123'
        });

      // セキュアなクッキー設定の確認
      const cookies = response.headers['set-cookie'];
      if (cookies) {
        expect(cookies.some(cookie => cookie.includes('HttpOnly'))).toBe(true);
        expect(cookies.some(cookie => cookie.includes('Secure'))).toBe(true);
      }
    });
  });

  describe('A03: Injection (インジェクション)', () => {
    
    test('SQLインジェクション攻撃が防がれる', async () => {
      const maliciousInputs = [
        "'; DROP TABLE customers; --",
        "1' OR '1'='1",
        "1'; UPDATE customers SET email='hacked@evil.com'; --",
        "1' UNION SELECT * FROM staff --"
      ];

      for (const input of maliciousInputs) {
        const response = await request(app)
          .get(`/api/v1/customers/${encodeURIComponent(input)}`)
          .set('Authorization', `Bearer ${await getValidTestToken()}`)
          .set('x-tenant-id', 'test-tenant');
        
        // 400 (Bad Request) または 404 (Not Found) が期待される
        expect([400, 404, 500]).toContain(response.status);
      }
    });

    test('NoSQLインジェクション攻撃が防がれる', async () => {
      const maliciousQueries = [
        { email: { $gt: "" } },
        { email: { $ne: null } },
        { $where: "function() { return true; }" }
      ];

      for (const query of maliciousQueries) {
        const response = await request(app)
          .get('/api/v1/customers')
          .query(query)
          .set('Authorization', `Bearer ${await getValidTestToken()}`)
          .set('x-tenant-id', 'test-tenant');
        
        expect([400, 422]).toContain(response.status);
      }
    });

    test('XSS攻撃が防がれる', async () => {
      const xssPayloads = [
        '<script>alert("XSS")</script>',
        'javascript:alert("XSS")',
        '<img src="x" onerror="alert(1)">',
        '<svg onload="alert(1)">'
      ];

      for (const payload of xssPayloads) {
        const response = await request(app)
          .post('/api/v1/customers')
          .set('Authorization', `Bearer ${await getValidTestToken()}`)
          .set('x-tenant-id', 'test-tenant')
          .send({
            name: payload,
            email: 'test@example.com',
            phone: '090-1234-5678'
          });
        
        // データが適切にサニタイズされているか確認
        if (response.status === 200 || response.status === 201) {
          expect(response.body.data?.name).not.toContain('<script>');
          expect(response.body.data?.name).not.toContain('javascript:');
        }
      }
    });
  });

  describe('A04: Insecure Design (安全でない設計)', () => {
    
    test('レート制限が適切に設定されている', async () => {
      const promises = [];
      
      // 短時間で大量のリクエストを送信
      for (let i = 0; i < 100; i++) {
        promises.push(
          request(app)
            .post('/api/v1/auth/login')
            .send({
              email: 'test@example.com',
              password: 'wrongpassword'
            })
        );
      }

      const responses = await Promise.all(promises);
      const tooManyRequestsResponses = responses.filter(r => r.status === 429);
      
      // レート制限が発動していることを確認
      expect(tooManyRequestsResponses.length).toBeGreaterThan(0);
    });

    test('ブルートフォース攻撃が防がれる', async () => {
      const passwords = [
        'password', '123456', 'admin', 'test', 'qwerty',
        'password123', 'admin123', '12345678', 'welcome'
      ];

      let blockedAttempts = 0;
      
      for (const password of passwords) {
        const response = await request(app)
          .post('/api/v1/auth/login')
          .send({
            email: 'test@example.com',
            password: password
          });
        
        if (response.status === 429 || response.status === 423) {
          blockedAttempts++;
        }
      }

      // 複数回の失敗後にアカウントロックまたはレート制限が発動
      expect(blockedAttempts).toBeGreaterThan(0);
    });
  });

  describe('A05: Security Misconfiguration (セキュリティ設定ミス)', () => {
    
    test('セキュリティヘッダーが適切に設定されている', async () => {
      const response = await request(app)
        .get('/health')
        .expect(200);

      // 重要なセキュリティヘッダーの確認
      expect(response.headers).toHaveProperty('x-content-type-options', 'nosniff');
      expect(response.headers).toHaveProperty('x-frame-options');
      expect(response.headers).toHaveProperty('x-xss-protection');
      expect(response.headers).toHaveProperty('strict-transport-security');
    });

    test('不要な情報が漏洩しない', async () => {
      const response = await request(app)
        .get('/api/v1/nonexistent-endpoint')
        .expect(404);

      // サーバー情報やスタック情報が漏洩しないことを確認
      expect(response.body.stack).toBeUndefined();
      expect(response.headers.server).toBeUndefined();
      expect(response.headers['x-powered-by']).toBeUndefined();
    });

    test('デバッグ情報が本番環境で無効化されている', async () => {
      const response = await request(app)
        .get('/api/v1/debug')
        .expect(404);

      expect(response.body).not.toHaveProperty('environment');
      expect(response.body).not.toHaveProperty('config');
    });
  });

  describe('A06: Vulnerable Components (脆弱なコンポーネント)', () => {
    
    test('知られた脆弱性のあるライブラリが使用されていない', async () => {
      // package.jsonの依存関係を確認
      const packageJson = require('../../../package.json');
      
      // 已知の脆弱なバージョンをチェック
      const vulnerablePackages = {
        'lodash': ['< 4.17.12'],
        'axios': ['< 0.21.1'],
        'express': ['< 4.17.3']
      };

      for (const [pkg, vulnerableVersions] of Object.entries(vulnerablePackages)) {
        if (packageJson.dependencies[pkg] || packageJson.devDependencies[pkg]) {
          // バージョンチェックロジック（簡略化）
          console.log(`Checking ${pkg} version...`);
        }
      }
    });
  });

  describe('A07: Identification and Authentication Failures (認証の失敗)', () => {
    
    test('弱いパスワードが拒否される', async () => {
      const weakPasswords = [
        '123',
        'password',
        'admin',
        'test',
        '12345678'
      ];

      for (const password of weakPasswords) {
        const response = await request(app)
          .post('/api/v1/auth/register')
          .send({
            email: 'weak-password-test@example.com',
            password: password,
            name: 'Test User',
            tenantId: 'test-tenant'
          });

        expect(response.status).toBe(400);
        expect(response.body.error).toMatch(/password/i);
      }
    });

    test('多要素認証が適切に動作する', async () => {
      // 2FA有効アカウントでのログインテスト
      const response = await request(app)
        .post('/api/v1/auth/login')
        .send({
          email: 'test-2fa@example.com',
          password: 'ValidPassword123!'
        });

      if (response.status === 200) {
        expect(response.body).toHaveProperty('requiresTwoFactor', true);
        expect(response.body.token).toBeUndefined(); // 2FA完了前はトークン未発行
      }
    });

    test('セッション管理が適切に行われる', async () => {
      // ログイン
      const loginResponse = await request(app)
        .post('/api/v1/auth/login')
        .send({
          email: 'test@example.com',
          password: 'ValidPassword123!'
        });

      const token = loginResponse.body.token;

      // セッション有効性確認
      const verifyResponse = await request(app)
        .get('/api/v1/auth/verify')
        .set('Authorization', `Bearer ${token}`)
        .expect(200);

      expect(verifyResponse.body.valid).toBe(true);

      // ログアウト
      await request(app)
        .post('/api/v1/auth/logout')
        .set('Authorization', `Bearer ${token}`)
        .expect(200);

      // ログアウト後のトークン無効性確認
      const invalidResponse = await request(app)
        .get('/api/v1/auth/verify')
        .set('Authorization', `Bearer ${token}`)
        .expect(401);
    });
  });

  describe('A08: Software and Data Integrity Failures (ソフトウェアとデータの整合性の失敗)', () => {
    
    test('データ整合性が保たれる', async () => {
      const validToken = await getValidTestToken();
      
      // 正常なデータで顧客を作成
      const createResponse = await request(app)
        .post('/api/v1/customers')
        .set('Authorization', `Bearer ${validToken}`)
        .set('x-tenant-id', 'test-tenant')
        .send({
          name: 'データ整合性テスト',
          email: 'integrity@example.com',
          phone: '090-1234-5678'
        })
        .expect(201);

      const customerId = createResponse.body.data.id;

      // データが正確に保存されているか確認
      const getResponse = await request(app)
        .get(`/api/v1/customers/${customerId}`)
        .set('Authorization', `Bearer ${validToken}`)
        .set('x-tenant-id', 'test-tenant')
        .expect(200);

      expect(getResponse.body.data).toMatchObject({
        name: 'データ整合性テスト',
        email: 'integrity@example.com',
        phone: '090-1234-5678'
      });
    });

    test('不正なデータ改ざんが検出される', async () => {
      const validToken = await getValidTestToken();
      
      const maliciousData = {
        name: 'Test User',
        email: 'test@example.com',
        phone: '090-1234-5678',
        totalSpent: 999999999, // 不正に高額な値
        visitCount: -1, // 不正な負の値
        tenantId: 'different-tenant' // 不正なテナントID
      };

      const response = await request(app)
        .post('/api/v1/customers')
        .set('Authorization', `Bearer ${validToken}`)
        .set('x-tenant-id', 'test-tenant')
        .send(maliciousData);

      expect([400, 422]).toContain(response.status);
    });
  });

  describe('A09: Security Logging and Monitoring Failures (セキュリティログとモニタリングの失敗)', () => {
    
    test('セキュリティイベントがログに記録される', async () => {
      // 不正なログイン試行
      await request(app)
        .post('/api/v1/auth/login')
        .send({
          email: 'test@example.com',
          password: 'wrongpassword'
        });

      // 不正なAPI呼び出し
      await request(app)
        .get('/api/v1/analytics/dashboard-kpis')
        .set('Authorization', 'Bearer invalid-token');

      // ログファイルまたはセキュリティイベントテーブルの確認
      // 実装に応じてログ確認ロジックを追加
    });

    test('異常なアクセスパターンが検出される', async () => {
      // 短時間での大量アクセス
      const promises = [];
      for (let i = 0; i < 50; i++) {
        promises.push(
          request(app)
            .get('/api/v1/customers')
            .set('Authorization', `Bearer ${await getValidTestToken()}`)
            .set('x-tenant-id', 'test-tenant')
        );
      }

      await Promise.all(promises);
      
      // 異常検知システムが動作していることを確認
      // （実装に応じてアラートまたはログを確認）
    });
  });

  describe('A10: Server-Side Request Forgery (SSRF)', () => {
    
    test('SSRF攻撃が防がれる', async () => {
      const maliciousUrls = [
        'http://localhost:22/',
        'http://127.0.0.1:3306/',
        'http://169.254.169.254/', // AWS metadata
        'file:///etc/passwd',
        'ftp://internal.server.com/'
      ];

      for (const url of maliciousUrls) {
        // 外部URL取得機能がある場合のテスト
        const response = await request(app)
          .post('/api/v1/external/fetch')
          .set('Authorization', `Bearer ${await getValidTestToken()}`)
          .set('x-tenant-id', 'test-tenant')
          .send({ url: url });

        expect([400, 403, 422]).toContain(response.status);
      }
    });
  });
});

// ヘルパー関数
async function getValidTestToken() {
  const response = await request(app)
    .post('/api/v1/auth/login')
    .send({
      email: 'test@example.com',
      password: 'ValidPassword123!'
    });
  
  return response.body.token;
}